{% extends 'GearsPilot/base.html' %}
{% block content %}


    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 60%;
                touch-action: none;
            }
        </style>

        {% load static %}
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="{% static 'GearsPilot/BabylonScripts/GUIFunctions.js' %}"> </script>

    </head>

    <!-- Grid -->
    <div class="w3-row">
      <!-- Blog entry -->
<div class="w3-card-4 w3-margin w3-white">
  <canvas id="renderCanvas" touch-action="none" onDrop = "dropHandler(event);"></canvas>
  <div id="tester" style = "width:100%;height:40%;"> </div>
</div>

</div>

    <script>

      Tester = document.getElementById("tester");
      var plt = Plotly.newPlot( Tester, [{
        x: [0],
        y: [0],}, {x:[0], y:[0]}],
        {
          margin : {t:0}
        });
      var time = 0;

      function addToGraph(x_data, y_data, traces) {
        Plotly.extendTraces("tester", {x:[[x_data]], y:[[y_data]]}, traces);
      }

      var canvas = document.getElementById("renderCanvas"); // Get the canvas element
      var engine = new BABYLON.Engine(canvas);

      var animationSpeed = 1;


      function speedSet(scene, value)
      {
        for (let animation_group of scene.animationGroups)
        {
          if (animation_group.isPlaying)
          {
              animation_group.speedRatio = value;
              animation_group.play(true);
          }
        }
      }



      function importJsonMeshes(scene, panel, sunTeeth, planetTeeth)
      {

        sunTeeth = Math.round(sunTeeth);
        PlanetTeeth = Math.round(planetTeeth);
        let base_address = "./static/GearsPilot/Sun_" + String(sunTeeth) + "_Planet_"+ String(planetTeeth) +"/";
        let filename = "Sun_" + String(sunTeeth) + "_Planet_" + String(planetTeeth) + ".glb";

        let noOfMeshes = scene.meshes.length - 1;
        for (let i = noOfMeshes; i > 0; i--)
        {
          scene.meshes[i].dispose();
        }
        BABYLON.SceneLoader.Append(base_address, filename, scene, function (scene, meshes) {
        scene.stopAllAnimations();
        scene.materials = [];
        for (let mesh of scene.meshes)
        {
          mesh.material = new BABYLON.StandardMaterial(mesh.name+"mat", scene);
        }

        var FixedRing = new BABYLON.AnimationGroup("FixedRing");
        var FixedSun = new BABYLON.AnimationGroup("FixedSun");

        for (let animation_group of scene.animationGroups)
        {
          if (animation_group.name.includes("FixedRing"))
          {
              FixedRing.addTargetedAnimation(animation_group.targetedAnimations[0].animation, animation_group.targetedAnimations[0].target);
              FixedRing.setWeightForAllAnimatables(1);
              FixedRing.play(true);
            }
          else if (animation_group.name.includes("FixedSun"))
            {
              FixedSun.addTargetedAnimation(animation_group.targetedAnimations[0].animation, animation_group.targetedAnimations[0].target);
              FixedSun.setWeightForAllAnimatables(0);
            }
        }

        scene.animationGroups.splice(0,scene.animationGroups.length -2);

        for (let i = panel.children.length - 1; i > 0; i--)
        {
          if (panel.children[i].typeName == "StackPanel")
          {
            panel.children[i].dispose();
          }
        }

        createWeightingRadioButtons(FixedRing, panel, true);
        createWeightingRadioButtons(FixedSun, panel);

        });
      }


      var createScene = function() {

        var scene = new BABYLON.Scene(engine);
        // Add a camera to the scene and attach it to the canvas
        var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, 0.6 * Math.PI / 2, 2, new BABYLON.Vector3(0,80,90), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(canvas, true);
        scene.activeCamera.panningSensibility = 50;

        // Add lights to the scene
        var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
        var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 1, -1), scene);

        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var panel = new BABYLON.GUI.StackPanel();
        panel.width = "220px";
        panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        advancedTexture.addControl(panel);

        var speedSlider = createSlider(panel, "Speed: ", 5, 0, animationSpeed, 0.01, function(value) {speedSet(scene, value);});

        importJsonMeshes(scene, panel, 5, 10);

        // create Planet which currently does nothing
        var planetSlider = createSlider(panel, "Planet Teeth: ", 10, 10, 10, 10, function(value) {
          console.log("Currently does nothing!!");
        });

        var sunSlider = createSlider(panel, "Sun Teeth: ", 20, 5, 5, 5, function(value) {
                let speedVal = speedSlider.value;
                let planetTeeth = planetSlider.value;
                importJsonMeshes(scene, panel, value, 10);
                speedSlider.value = 0.2;
              });

        var pauseButton = createButton(panel, "Pause", "Pause", function() {

        });

        var fullScreenButton = createButton(panel, "FullScreen", "FullScreen", function() {
          if (engine.isFullscreen)
          {engine.exitFullscreen();}
          else
          {engine.enterFullscreen();}
        });

        var Selected = null;
        var defaultDiffuseColor = new BABYLON.Color3(1,1,1);
        var selectedDiffuseColor = new BABYLON.Color3(1,0.65,0);
        scene.onPointerObservable.add(function(evt) {
          let pickResult = evt.pickInfo
            if (pickResult.hit)
            {
              for (let mesh of scene.meshes)
              {
                if (mesh == pickResult.pickedMesh)
                  {mesh.material.diffuseColor = selectedDiffuseColor;
                  Selected = mesh;}
                else
                {mesh.material.diffuseColor = defaultDiffuseColor;}
              }
          }
          else
          {Selected = null;}
        }, BABYLON.PointerEventTypes.POINTERUP);

        scene.registerBeforeRender(function () {
          if (Selected)
          { let pos = Selected.absolutePosition;
            time += engine.getDeltaTime()/1000;
            Plotly.extendTraces("tester", {x:[[time], [time]], y:[[pos.x], [pos.z]]}, [0,1], 200);
          }

        });

        return scene;
      }

      var scene = createScene(); //Call the createScene function


      // Register a render loop to repeatedly render the scene
      engine.runRenderLoop(function () {
              scene.render();
      });

      // Watch for browser/canvas resize events
      window.addEventListener("resize", function () {
              engine.resize();
      });

    </script>

   </body>

</html>

{% endblock content %}
